<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lesson JSON Translation Editor — v1.9.0</title>
  <style>
    :root{
      --brand:#081A35; --muted:#6b7280; --ok:#16a34a; --warn:#e11d48; --line:#e5e7eb; --bg:#f5f7fb;
      --qhdr-bg:#eef3ff; --qhdr-fg:#0b2269; --qhdr-accent:#3b82f6;
    }
    html,body{margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Inter,Arial,sans-serif;background:var(--bg);color:#0f172a}
    header{padding:16px 20px;background:#fff;border-bottom:1px solid var(--line);position:sticky;top:0;z-index:10}
    header h1{font-size:18px;margin:0 0 4px 0;color:var(--brand);display:flex;gap:10px;align-items:center}
    header .ver{font-size:11px;color:#fff;background:#0f172a;border-radius:999px;padding:2px 8px}
    header .sub{color:var(--muted);font-size:13px;display:flex;gap:12px;flex-wrap:wrap}
    .b{font-weight:600;color:#0f172a}

    .container{max-width:1200px;margin:0 auto;padding:16px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
    .toolbar > * {flex:0 0 auto}
    select, input[type="text"], input[type="password"], textarea, button{border:1px solid var(--line);border-radius:8px;padding:8px 10px;background:#fff;font:inherit}
    button{cursor:pointer}
    button.primary{background:var(--brand);color:#fff;border-color:transparent}
    button.ghost{background:#fff}
    label.chk{display:flex;gap:8px;align-items:center;font-size:13px;color:#334155}

    details.box{background:#fff;border:1px solid var(--line);border-radius:10px;padding:10px;margin-bottom:12px}
    details.box summary{cursor:pointer;font-weight:600}
    textarea#jsonInput{width:100%;min-height:160px;font-family:ui-monospace,SFMono-Regular,Consolas,Monaco,monospace}

    .status{font-size:12px;color:var(--muted)}
    .pill{display:inline-block;border-radius:999px;padding:2px 8px;font-size:12px;border:1px solid var(--line);background:#fff}

    table{width:100%;border-collapse:separate;border-spacing:0;background:#fff;border:1px solid var(--line);border-radius:12px;overflow:hidden}
    thead th{position:sticky;top:64px;background:#f9fafb;border-bottom:1px solid var(--line);font-size:12px;text-transform:uppercase;letter-spacing:.04em;color:#334155;padding:8px}
    tbody td{border-bottom:1px solid var(--line);vertical-align:top;padding:8px}
    tbody tr:nth-child(odd){background:#fcfdff}
    .item{font-size:13px}
    .base, .loc{min-width:260px}
    textarea.edit{width:100%;min-height:60px;resize:vertical;font-family:inherit}
    .len{color:#475569;font-size:12px;text-align:right}

    /* Question header row (qhdr) — bigger + nicer color + chevron */
    .qhdr{
      background:var(--qhdr-bg);
      color:var(--qhdr-fg);
      border-left:4px solid var(--qhdr-accent);
      padding:10px 12px;
      margin:6px 0;
      border-radius:8px;
      font-size:15px;
      font-weight:700;
      display:flex;
      align-items:center;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .qhdr .chev{
      display:inline-block; width:10px; transform:rotate(0deg);
      transition:transform .15s ease;
      color:var(--qhdr-accent); font-weight:800;
    }
    .qhdr.collapsed .chev{ transform:rotate(-90deg); }
    .qhdr .meta{
      font-weight:600; opacity:.85; font-size:13px; color:#334155;
      margin-left:auto;
    }

    .footer{display:flex;gap:10px;justify-content:space-between;margin-top:12px;align-items:center}
    .counter{font-size:12px;color:#334155}
  </style>
</head>
<body>
  <header>
    <h1>
      Lesson JSON Translation Editor
      <span class="ver">v1.9.0</span>
    </h1>
    <div class="sub">
      <span>Deep-link with <code>?lang=sv_SE</code> • <code>?showMeta=1</code> shows explanation/right/wrong</span>
      <span id="qTotal" class="b"></span>
    </div>
  </header>

  <div class="container">
    <details class="box" open>
      <summary>Load / Paste JSON</summary>
      <div class="status">Auto-load: global <code>LESSON</code>/<code>lessonData</code> → textarea → GitHub (if saved PAT). You can also paste JSON anywhere on the page.</div>
      <div class="toolbar">
        <button id="btnLoadTextarea" class="ghost">Load JSON from textarea</button>
        <button id="btnDownload" class="ghost">Export Updated JSON</button>
        <button id="btnCSV" class="ghost">Export CSV (visible rows)</button>
      </div>
      <textarea id="jsonInput" placeholder='Paste the JSON for your lesson here (either the object itself, {"lessonData": ...}, or a JS file that assigns to lessonData).'></textarea>
    </details>

    <details class="box" open>
      <summary>GitHub</summary>
      <div class="status">Repo details are preconfigured. Enter your <strong>Personal Access Token</strong> (fine-grained or classic). Token is saved to localStorage for auto-load next visit.</div>
      <div class="toolbar">
        <input id="ghToken" type="password" placeholder="Personal Access Token" style="min-width:320px" />
        <button id="btnGHLoad" class="ghost">Load from GitHub</button>
        <button id="btnGHSave" class="primary">Save to GitHub</button>
      </div>
      <div class="status" id="ghStatus">—</div>
    </details>

    <div class="toolbar">
      <label>Locale
        <select id="localeSelect"></select>
      </label>
      <label>Base (comparison)
        <select id="baseSelect"></select>
      </label>
      <input id="search" type="text" placeholder="Search item text…" />
      <label class="chk"><input type="checkbox" id="missingOnly"/> Show missing/empty only</label>
      <label class="chk"><input type="checkbox" id="ensureKeys"/> Ensure keys exist for selected locale when exporting/saving</label>
      <label class="chk"><input type="checkbox" id="hideMeta"/> Hide explanation/right/wrong</label>

      <button id="btnExpandAll" class="ghost">Expand all</button>
      <button id="btnCollapseAll" class="ghost">Collapse all</button>

      <span id="counts" class="counter">—</span>
    </div>

    <table id="grid" hidden>
      <thead>
        <tr>
          <th style="width:36px">#</th>
          <th>Item</th>
          <th>Base</th>
          <th>Locale</th>
          <th style="width:120px;text-align:right">Len</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <div class="footer">
      <span class="counter" id="footerCounts">—</span>
      <span class="counter" id="visibleQ">—</span>
    </div>
  </div>

<script>
(() => {
  // ---------- Config / Version ----------
  const VERSION = 'v1.9.0';

  // ---------- DOM / utils ----------
  const $ = (s, r = document) => r.querySelector(s);
  const isLocaleKey = (k) => k === 'basic' || /^[a-z]{2}_[A-Z]{2}$/.test(k);
  const storage = {
    get(k, d){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : d; }catch{ return d; } },
    set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} }
  };

  // UTF-8 safe Base64
  function toB64Utf8(str){
    const bytes = new TextEncoder().encode(str);
    let bin = ''; for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function fromB64Utf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }

  // GitHub target
  const GITHUB = { owner:'johanpantzare', repo:'video-course', branch:'master', path:'translation.json', token:'', sha:'' };

  let LESSON = null, RECORDS = [], LOCALES = new Set(), WRAPPER = { has:false, before:'', after:'' };
  let QINFO = []; // per-question meta: {id, type, answersCount}
  let collapsed = new Set(storage.get('collapsedQs', [])); // remember collapsed questions

  function download(filename, text, type='application/json'){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], {type}));
    a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
  }
  function downloadCSV(filename, rows){
    const esc = (s) => '"' + (String(s??'').replaceAll('"','""')) + '"';
    const header = ['#','question','item','path','baseLocale','base','locale','value'].map(esc).join(',');
    const lines = rows.map(r => [r.idx, r.qnum, r.item, r.path, r.baseLocale, r.base, r.locale, r.value].map(esc).join(','));
    const csv = [header, ...lines].join('\n');
    download(filename, csv, 'text/csv');
  }
  function traverse(obj, cb, path = ''){
    cb(obj, path);
    if (Array.isArray(obj)){
      obj.forEach((v,i) => traverse(v, cb, path + '[' + i + ']'));
    } else if (obj && typeof obj === 'object'){
      for (const [k,v] of Object.entries(obj)){
        traverse(v, cb, path + (path?'.':'') + k);
      }
    }
  }
  function collectLocales(obj){
    try{ (obj.languages||[]).forEach(x => x?.locale && LOCALES.add(x.locale)); }catch{}
    traverse(obj, (node) => {
      if (node && typeof node === 'object' && !Array.isArray(node)){
        const keys = Object.keys(node);
        if (keys.some(isLocaleKey)){
          keys.filter(isLocaleKey).forEach(k => LOCALES.add(k));
        }
      }
    });
  }

  function labelFor(rec){
    if (rec.meta?.kind === 'answer'){
      return `Answer ${Number(rec.meta.position)+1}`;
    }
    const f = rec.meta?.field;
    if (f === 'text') return 'Question';
    if (f === 'title') return 'Title';
    if (f === 'explanationText') return 'Explanation';
    if (f === 'rightAnswerText') return 'Right answer text';
    if (f === 'wrongAnswerText') return 'Wrong answer text';
    return f || rec.path;
  }

  // Build rows: questions.* + answers[].body (store question index & answer position)
  function collectTranslatables(obj){
    const FIELDS = ['title','text','explanationText','rightAnswerText','wrongAnswerText'];
    const recs = [];
    const questions = Array.isArray(obj.questions)
      ? obj.questions
      : (obj.lessonData && Array.isArray(obj.lessonData.questions) ? obj.lessonData.questions : []);

    QINFO = questions.map(q => ({
      id: q?.id ?? '',
      type: q?.questionType ?? '',
      answersCount: Array.isArray(q?.answers) ? q.answers.length : 0
    }));

    questions.forEach((q, i) => {
      FIELDS.forEach(field => {
        const node = q?.[field];
        if (node && typeof node === 'object' && !Array.isArray(node)){
          const keys = Object.keys(node);
          if (keys.some(isLocaleKey)){
            const locales = keys.filter(isLocaleKey);
            const baseLocale = locales.includes('en_US') ? 'en_US' : (locales.includes('basic') ? 'basic' : locales[0]);
            recs.push({ qIndex:i, path:`questions[${i}].${field}`, node, baseLocale, meta:{kind:'question', field} });
          }
        }
      });
      const answers = Array.isArray(q.answers) ? q.answers : [];
      answers.forEach((ans, j) => {
        const node = ans?.body;
        if (node && typeof node === 'object' && !Array.isArray(node)){
          const keys = Object.keys(node);
          if (keys.some(isLocaleKey)){
            const locales = keys.filter(isLocaleKey);
            const baseLocale = locales.includes('en_US') ? 'en_US' : (locales.includes('basic') ? 'basic' : locales[0]);
            recs.push({ qIndex:i, path:`questions[${i}].answers[${j}].body`, node, baseLocale, meta:{kind:'answer', isCorrect: ans?.isCorrect === true, position:j} });
          }
        }
      });
    });
    return recs;
  }

  function populateLocaleSelects(){
    const locs = Array.from(LOCALES).sort();
    const sel = $('#localeSelect'), baseSel = $('#baseSelect');
    sel.innerHTML = ''; baseSel.innerHTML = '';
    for (const l of locs){
      const o1 = document.createElement('option'); o1.value = l; o1.textContent = l; sel.appendChild(o1);
      const o2 = document.createElement('option'); o2.value = l; o2.textContent = l; baseSel.appendChild(o2);
    }
    sel.value = locs.includes('sv_SE') ? 'sv_SE' : (locs.includes('en_US')?'en_US':locs[0]||'en_US');
    baseSel.value = locs.includes('en_US') ? 'en_US' : (locs.includes('basic')?'basic':locs[0]||'en_US');
  }

  function setUrlLangParam(lang){
    try{
      const u = new URL(location.href);
      if (lang) u.searchParams.set('lang', lang); else u.searchParams.delete('lang');
      history.replaceState(null, '', u.toString());
    }catch{}
  }

  function renderTable(){
    const locale = $('#localeSelect').value;
    const base = $('#baseSelect').value;
    const q = $('#search').value.trim().toLowerCase();
    const missingOnly = $('#missingOnly').checked;
    const hideMeta = $('#hideMeta').checked;

    const tbody = document.getElementById('tbody');
    const grid = document.getElementById('grid');
    tbody.innerHTML = '';

    // Group records by question index
    const byQ = new Map();
    for (const rec of RECORDS){
      if (hideMeta && /\.(explanationText|rightAnswerText|wrongAnswerText)$/.test(rec.path)) continue;
      (byQ.get(rec.qIndex) || byQ.set(rec.qIndex, []).get(rec.qIndex)).push(rec);
    }
    // Sort items inside each question
    const orderKey = (rec) => {
      if (rec.meta?.kind === 'answer') return 200 + (rec.meta.position ?? 0);
      const f = rec.meta?.field;
      if (f === 'title') return 10;
      if (f === 'text') return 20;
      if (f === 'explanationText') return 500;
      if (f === 'rightAnswerText') return 510;
      if (f === 'wrongAnswerText') return 520;
      return 999;
    };
    for (const arr of byQ.values()) arr.sort((a,b)=>orderKey(a)-orderKey(b));

    let idx = 0, shown = 0, missing = 0;
    const rowsForCSV = [];
    const visibleQuestions = new Set();

    const totalQuestions = QINFO.length;
    for (let qi = 0; qi < totalQuestions; qi++){
      const recs = byQ.get(qi) || [];

      // Check if any row in this question passes the search/missing filter
      let hasVisibleRow = false;
      for (const rec of recs){
        const baseText = rec.node?.[base] ?? '';
        const locText = rec.node?.[locale] ?? '';
        const isMissing = (locText ?? '') === '';
        const hay = (labelFor(rec) + ' ' + baseText + ' ' + locText).toLowerCase();
        if (q && !hay.includes(q)) continue;
        if (missingOnly && !isMissing) continue;
        hasVisibleRow = true; break;
      }
      if (!hasVisibleRow) continue;

      visibleQuestions.add(qi);

      // -------- Question header row
      const qmeta = QINFO[qi] || {};
      const isCollapsed = collapsed.has(qi);
      const qRow = document.createElement('tr');
      const qCell = document.createElement('td');
      qCell.colSpan = 5;
      qCell.className = 'qhdr' + (isCollapsed ? ' collapsed' : '');
      qCell.setAttribute('role','button');
      qCell.setAttribute('tabindex','0');
      qCell.dataset.qindex = String(qi);
      qCell.innerHTML = `
        <span class="chev">▸</span>
        <span>Question ${qi+1} of ${totalQuestions}</span>
        <span class="meta">ID ${qmeta.id ?? ''} • ${qmeta.type || ''} • ${qmeta.answersCount||0} answers</span>
      `;
      // Toggle behavior
      const toggle = () => {
        if (collapsed.has(qi)) collapsed.delete(qi); else collapsed.add(qi);
        storage.set('collapsedQs', Array.from(collapsed));
        renderTable(); // re-render to apply visibility + chevron
      };
      qCell.addEventListener('click', toggle);
      qCell.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); toggle(); }});
      qRow.appendChild(qCell);
      tbody.appendChild(qRow);

      // -------- Item rows (hidden if collapsed)
      if (!isCollapsed){
        for (const rec of recs){
          const baseText = rec.node?.[base] ?? '';
          const locText = rec.node?.[locale] ?? '';
          const isMissing = (locText ?? '') === '';
          if (isMissing) missing++;

          const hay = (labelFor(rec) + ' ' + baseText + ' ' + locText).toLowerCase();
          if (q && !hay.includes(q)) continue;
          if (missingOnly && !isMissing) continue;

          shown++; idx++;

          const tr = document.createElement('tr');

          const tdIdx = document.createElement('td'); tdIdx.textContent = String(idx); tr.appendChild(tdIdx);

          const tdItem = document.createElement('td'); tdItem.className = 'item';
          const label = document.createElement('span'); label.textContent = labelFor(rec);
          tdItem.appendChild(label);
          if (rec.meta?.kind === 'answer' && rec.meta.isCorrect){
            const pill = document.createElement('span');
            pill.className = 'pill'; pill.textContent = 'Correct'; pill.style.marginLeft = '6px';
            tdItem.appendChild(pill);
          }
          tr.appendChild(tdItem);

          const tdBase = document.createElement('td'); tdBase.className = 'base';
          const baseArea = document.createElement('div'); baseArea.textContent = baseText; tdBase.appendChild(baseArea); tr.appendChild(tdBase);

          const tdLoc = document.createElement('td'); tdLoc.className = 'loc';
          const ta = document.createElement('textarea');
          ta.className = 'edit'; ta.value = locText ?? '';
          // Collapse small height for meta fields if user chooses to show them
          const collapseByDefault = /\.(explanationText|rightAnswerText|wrongAnswerText)$/.test(rec.path);
          if (collapseByDefault){
            ta.style.height = '22px';
            ta.style.overflow = 'hidden';
            ta.style.resize = 'none';
            ta.addEventListener('focus', () => {
              ta.style.height = '60px';
              ta.style.overflow = 'auto';
              ta.style.resize = 'vertical';
            }, {once:true});
          }
          ta.addEventListener('input', (e) => {
            rec.node[locale] = e.target.value; // bind live
            updateCounts();
            tdLen.textContent = String(e.target.value.length);
          });
          tdLoc.appendChild(ta); tr.appendChild(tdLoc);

          const tdLen = document.createElement('td'); tdLen.className = 'len'; tdLen.textContent = String((ta.value||'').length); tr.appendChild(tdLen);

          tbody.appendChild(tr);

          rowsForCSV.push({ idx, qnum: qi+1, item: labelFor(rec), path: rec.path, baseLocale: base, base: baseText, locale, value: ta.value });
        }
      }
    }

    grid.hidden = false;
    $('#counts').textContent = `${shown} items · ${missing} missing in ${$('#localeSelect').value}`;
    $('#footerCounts').textContent = `${RECORDS.length} total translatable items`;
    $('#visibleQ').textContent = `${Array.from(new Set([...collapsed].filter(x=>x<QINFO.length ? false : false))).length} / ${QINFO.length} questions collapsed`;
    // The above visibleQ line purposely counts only collapsed if within range
    const collapsedCount = Array.from(collapsed).filter(x => x >=0 && x < QINFO.length).length;
    $('#visibleQ').textContent = `${QINFO.length - collapsedCount} visible / ${QINFO.length} total questions`;

    // store CSV rows on the table
    document.getElementById('grid').dataset.csv = JSON.stringify(rowsForCSV);
  }

  function updateCounts(){
    const locale = $('#localeSelect').value;
    const hideMeta = $('#hideMeta').checked;
    let missing = 0, total = 0;
    for (const rec of RECORDS){
      if (hideMeta && /\.(explanationText|rightAnswerText|wrongAnswerText)$/.test(rec.path)) continue;
      total++;
      if ((rec.node?.[locale]??'') === '') missing++;
    }
    $('#counts').textContent = `${total} items · ${missing} missing in ${locale}`;
  }

  function extractLessonFromText(text){
    const t = text.trim();
    if (t.startsWith('{')){
      const obj = JSON.parse(t);
      return { lesson: obj.lessonData || obj, wrapper:{has:false,before:'',after:''} };
    }
    const idx = t.search(/\b(?:var|let|const)\s+lessonData\s*=/);
    if (idx === -1) throw new Error('Not valid JSON and no "lessonData" assignment found.');
    const braceStart = t.indexOf('{', idx);
    if (braceStart === -1) throw new Error('Could not find opening { after lessonData =');
    let i = braceStart, depth = 0, inStr = false, strCh = '', esc = false;
    for (; i < t.length; i++){
      const ch = t[i];
      if (inStr){
        if (esc){ esc = false; }
        else if (ch === '\\'){ esc = true; }
        else if (ch === strCh){ inStr = false; strCh = ''; }
      } else {
        if (ch === '"' || ch === "'"){ inStr = true; strCh = ch; }
        else if (ch === '{'){ depth++; }
        else if (ch === '}'){ depth--; if (depth === 0) { i++; break; } }
      }
    }
    if (depth !== 0) throw new Error('Unbalanced braces in file.');
    const jsonText = t.slice(braceStart, i);
    const before = t.slice(0, braceStart);
    const after  = t.slice(i).replace(/^[\s;]*/, '');
    const obj = JSON.parse(jsonText);
    return { lesson: obj, wrapper:{has:true,before,after} };
  }

  function loadFromJSONObj(obj){
    LESSON = obj.lessonData || obj;
    if (!LESSON || typeof LESSON !== 'object') throw new Error('Could not find a valid object. Paste either the lesson object or {"lessonData": ...}');
    RECORDS = []; LOCALES = new Set();
    collectLocales(LESSON);
    RECORDS = collectTranslatables(LESSON);
    populateLocaleSelects();

    // Show total questions prominently
    const totalQ = Array.isArray(LESSON.questions) ? LESSON.questions.length : 0;
    $('#qTotal').textContent = `${totalQ} questions detected`;

    // Apply ?lang=
    try{
      const urlParams = new URLSearchParams(location.search);
      const lang = urlParams.get('lang');
      const showMeta = urlParams.get('showMeta');
      if (lang) {
        const sel = $('#localeSelect');
        if ([...sel.options].some(o => o.value === lang)) sel.value = lang;
      }
      // default: hide meta; but if ?showMeta=1 present, uncheck
      const hideMetaBox = $('#hideMeta');
      hideMetaBox.checked = !(showMeta === '1' || showMeta === 'true');
    }catch{}
    setUrlLangParam($('#localeSelect').value);

    renderTable();
  }

  // ---------- UI buttons ----------
  $('#btnLoadTextarea').addEventListener('click', () => {
    try{
      const raw = $('#jsonInput').value.trim();
      if (!raw) { alert('Paste JSON first.'); return; }
      const {lesson, wrapper} = extractLessonFromText(raw);
      WRAPPER = wrapper;
      loadFromJSONObj(lesson);
    } catch (e) {
      alert('Invalid input: ' + e.message);
    }
  });

  $('#btnDownload').addEventListener('click', () => {
    const ensure = $('#ensureKeys').checked;
    const locale = $('#localeSelect').value;
    if (!LESSON){ alert('Load JSON first.'); return; }
    if (ensure){ for (const rec of RECORDS){ if (!(locale in rec.node)) rec.node[locale] = rec.node?.en_US ?? rec.node?.basic ?? ''; } }
    const json = JSON.stringify(LESSON, null, 2);
    if (WRAPPER.has){
      const wrapped = 'var lessonData = ' + json + ';\n';
      download('translation.wrapped.js', wrapped, 'text/javascript');
    } else {
      download('lessonData.updated.json', json);
    }
  });

  $('#btnCSV').addEventListener('click', () => {
    const grid = $('#grid');
    const rows = JSON.parse(grid.dataset.csv || '[]');
    if (!rows.length){ alert('Nothing to export. Load JSON first.'); return; }
    downloadCSV('lesson_strings.csv', rows);
  });

  $('#localeSelect').addEventListener('change', () => {
    setUrlLangParam($('#localeSelect').value);
    renderTable(); updateCounts();
  });
  $('#baseSelect').addEventListener('change', () => { renderTable(); updateCounts(); });
  $('#missingOnly').addEventListener('change', () => { renderTable(); updateCounts(); });
  $('#search').addEventListener('input', renderTable);
  $('#hideMeta').addEventListener('change', () => { renderTable(); updateCounts(); });

  // Expand/Collapse all
  $('#btnExpandAll').addEventListener('click', () => {
    collapsed.clear(); storage.set('collapsedQs', Array.from(collapsed)); renderTable();
  });
  $('#btnCollapseAll').addEventListener('click', () => {
    // collapse all existing questions
    const count = QINFO.length;
    collapsed = new Set(Array.from({length:count}, (_,i)=>i));
    storage.set('collapsedQs', Array.from(collapsed)); renderTable();
  });

  // ---------- GitHub integration ----------
  const ghStatus = (msg) => { $('#ghStatus').textContent = msg || ''; };
  function ghReadToken(){
    GITHUB.token = $('#ghToken').value.trim();
    try { localStorage.setItem('ghToken', GITHUB.token || ''); } catch {}
  }
  async function withAuthTry(fn){
    const t = (GITHUB.token||'').trim();
    if (!t) throw new Error('Personal Access Token required.');
    try { return await fn({ Authorization: `Bearer ${t}` }); }
    catch (e1) {
      const msg = String(e1 && e1.message || '');
      if (!msg.includes('401')) throw e1;
      return await fn({ Authorization: `token ${t}` });
    }
  }
  async function fetchSha(headers){
    const url = `https://api.github.com/repos/${encodeURIComponent(GITHUB.owner)}/${encodeURIComponent(GITHUB.repo)}/contents/${encodeURIComponent(GITHUB.path)}?ref=${encodeURIComponent(GITHUB.branch)}`;
    const res = await fetch(url, { headers });
    if (res.status === 404) return '';
    if (!res.ok){ const t = await res.text().catch(()=> ''); throw new Error(`Pre-save sha fetch failed (${res.status}): ${t || res.statusText}`); }
    const data = await res.json();
    return data.sha || '';
  }
  async function githubLoad(){
    ghReadToken(); ghStatus('Loading…');
    await withAuthTry(async (auth) => {
      const headers = { 'Accept':'application/vnd.github+json','X-GitHub-Api-Version':'2022-11-28', ...auth };
      const url = `https://api.github.com/repos/${encodeURIComponent(GITHUB.owner)}/${encodeURIComponent(GITHUB.repo)}/contents/${encodeURIComponent(GITHUB.path)}?ref=${encodeURIComponent(GITHUB.branch)}`;
      const res = await fetch(url, { headers });
      if (res.status === 404){ ghStatus('File not found on repo/branch. Click “Save to GitHub” to create it.'); GITHUB.sha=''; return; }
      if (!res.ok){ ghStatus(`Error ${res.status}: ${await res.text().catch(()=>res.statusText)}`); return; }
      const data = await res.json();
      if (!data.content){ ghStatus('No content in response.'); return; }
      GITHUB.sha = data.sha;
      const text = fromB64Utf8(data.content);
      $('#jsonInput').value = text;
      try {
        const {lesson, wrapper} = extractLessonFromText(text);
        WRAPPER = wrapper;
        loadFromJSONObj(lesson);
        ghStatus('Loaded ✔');
      } catch(e){ ghStatus('Fetched, but parse failed: ' + e.message); }
    });
  }
  async function githubSave(){
    ghReadToken(); ghStatus('Saving…');
    if (!LESSON){ ghStatus('Load JSON before saving.'); return; }
    const ensure = $('#ensureKeys').checked;
    const locale = $('#localeSelect').value;
    if (ensure){ for (const rec of RECORDS){ if (!(locale in rec.node)) rec.node[locale] = rec.node?.en_US ?? rec.node?.basic ?? ''; } }
    const json = JSON.stringify(LESSON, null, 2);
    const contentText = WRAPPER.has ? ('var lessonData = ' + json + ';\n') : json;
    await withAuthTry(async (auth) => {
      const headers = { 'Accept':'application/vnd.github+json','X-GitHub-Api-Version':'2022-11-28','Content-Type':'application/json', ...auth };
      let sha = '';
      try { sha = await fetchSha(headers); } catch(e){ ghStatus(e.message); return; }
      const body = { message:'Update lesson translations', content: toB64Utf8(contentText), branch: GITHUB.branch, ...(sha ? { sha } : {}) };
      const url = `https://api.github.com/repos/${encodeURIComponent(GITHUB.owner)}/${encodeURIComponent(GITHUB.repo)}/contents/${encodeURIComponent(GITHUB.path)}`;
      let res = await fetch(url, { method:'PUT', headers, body: JSON.stringify(body) });
      if (res.status === 409){
        try { sha = await fetchSha(headers); } catch(e){ ghStatus('Retry failed fetching sha: ' + e.message); return; }
        const body2 = { ...body, ...(sha ? { sha } : {}) };
        res = await fetch(url, { method:'PUT', headers, body: JSON.stringify(body2) });
      }
      if (!res.ok){
        const t = await res.text().catch(()=> '');
        let msg = t; try { msg = JSON.parse(t).message || msg; } catch {}
        if (res.status === 401) { ghStatus('401 Unauthorized: check token type/scopes and repo access. ' + msg); return; }
        if (res.status === 403) { ghStatus('403 Forbidden: Branch protection or missing Contents: Read & write. ' + msg); return; }
        if (res.status === 404) { ghStatus('404 Not Found: repo/branch/path not accessible for this token. ' + msg); return; }
        ghStatus(`Save failed (${res.status}): ${msg || res.statusText}`); return;
      }
      const out = await res.json();
      GITHUB.sha = out?.content?.sha || sha;
      ghStatus('Saved ✔');
    });
  }
  $('#btnGHLoad').addEventListener('click', () => { githubLoad().catch(e=>ghStatus('Load error: '+e.message)); });
  $('#btnGHSave').addEventListener('click', () => { githubSave().catch(e=>ghStatus('Save error: '+e.message)); });

  // Paste-to-load anywhere
  window.addEventListener('paste', (e) => {
    const text = (e.clipboardData || window.clipboardData)?.getData('text');
    if (!text) return;
    try {
      const obj = JSON.parse(text);
      if (obj && typeof obj === 'object') {
        LESSON = obj.lessonData || obj;
        WRAPPER = {has:false,before:'',after:''};
        loadFromJSONObj(LESSON);
        $('#jsonInput').value = JSON.stringify(obj, null, 2);
        ghStatus('JSON loaded from paste ✔');
      }
    } catch {}
  });

  function debounced(fn, ms=400){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
  const tokenInput = $('#ghToken');
  tokenInput.addEventListener('input', debounced(() => { ghReadToken(); if (GITHUB.token) githubLoad().catch(e=>ghStatus('Load error: '+e.message)); }, 500));

  // Init auto-load
  (function initAutoLoad(){
    // default hide meta unless ?showMeta=1
    try{
      const p = new URLSearchParams(location.search);
      const showMeta = p.get('showMeta');
      $('#hideMeta').checked = !(showMeta === '1' || showMeta === 'true');
    }catch{}

    // globals
    if (typeof window.LESSON !== 'undefined') { try { loadFromJSONObj(window.LESSON); ghStatus('Loaded from global LESSON ✔'); return; } catch {} }
    if (typeof window.lessonData !== 'undefined') { try { loadFromJSONObj(window.lessonData); ghStatus('Loaded from global lessonData ✔'); return; } catch {} }

    // textarea
    const raw = $('#jsonInput').value.trim();
    if (raw) { try { const {lesson, wrapper} = extractLessonFromText(raw); WRAPPER = wrapper; loadFromJSONObj(lesson); ghStatus('Loaded from textarea ✔'); return; } catch {} }

    // GitHub via saved token
    try {
      const saved = localStorage.getItem('ghToken') || '';
      if (saved) { tokenInput.value = saved; GITHUB.token = saved; githubLoad().catch(e=>ghStatus('Load error: '+e.message)); }
      else { ghStatus('Tip: paste a PAT to auto-load from GitHub.'); }
    } catch { ghStatus('Ready. Paste JSON or enter a PAT to load from GitHub.'); }
  })();
})();
</script>
</body>
</html>
